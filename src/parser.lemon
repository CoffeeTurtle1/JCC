%include {

#include <stdlib.h>
#include <string.h>

#include "ast.h"
#include "error.h"
#include "malloc_or_die.h"

static DataType *check_expr_type(AstNode *expr);

// Location info
char *cur_filename; // Filename global
static int cur_line_num;
static char *cur_tok_str;

// Root node for the AST
static AstNode *ast_root_node;

// Data types

static int is_float_type(DataType *t)
{
    switch (t->type) {
    case TYPE_FLOAT:
    case TYPE_DOUBLE:
    case TYPE_LDOUBLE:
        return 1;
    default:
        return 0;
    }
}

static int is_int_type(DataType *t)
{
    switch (t->type) {
    case TYPE_INT:
    case TYPE_CHAR:
    case TYPE_BOOL:
    case TYPE_LONG:
    case TYPE_LLONG:
    case TYPE_SHORT:
        return 1;
    default:
        return 0;
    }
}

static int is_arith_type(DataType *t)
{
    return is_int_type(t) || is_float_type(t);
}

static int is_scalar_type(DataType *t)
{
    return is_arith_type(t) || t->type == TYPE_POINTER;
}

// Compare data types
static int is_type_equal(DataType *type_a, DataType *type_b)
{
    if (type_a->type == type_b->type                       ||
        type_a->is_unsigned == type_b->is_unsigned         ||
        type_a->storage_specs == type_b->storage_specs     ||
        type_a->type_qualifiers == type_b->type_qualifiers ||
        is_type_equal(type_a->pointer, type_b->pointer))
        return 1;
    return 0;
}

// Expressions

// TODO: implement this function properly
static DataType *usual_arith_conv(DataType *a, DataType *b)
{
    DataType *t = malloc(sizeof(DataType));

    if (a->type < b->type) {
        memcpy(t, b, sizeof(DataType));
        return t;
    }

    memcpy(t, a, sizeof(DataType));
    return t;
}

static DataType *check_binary_op(AstNode *expr)
{
    DataType *rhs_type = check_expr_type(expr->binary_right);
    DataType *lhs_type = check_expr_type(expr->binary_left);

    // This may not be the best way to do this
    switch (expr->binary_op) {
    // Addition
    case OP_PLUS:
        if (is_arith_type(lhs_type) && is_arith_type(rhs_type))
            return usual_arith_conv(lhs_type, rhs_type);
        if (lhs_type->type == TYPE_POINTER && is_int_type(rhs_type))
            return lhs_type;
        if (is_int_type(lhs_type) && rhs_type->type == TYPE_POINTER)
            return rhs_type;
        break;
    // Subtracting
    case OP_MINUS:
        if (is_arith_type(lhs_type) && is_arith_type(rhs_type))
            return usual_arith_conv(lhs_type, rhs_type);
        if (lhs_type->type == TYPE_POINTER && rhs_type->type == TYPE_POINTER)
            return lhs_type;
        if (lhs_type->type == TYPE_POINTER && is_int_type(rhs_type))
            return lhs_type;
        break;
    case OP_MULT:
    case OP_DIV:
    case OP_MODULO:
    case OP_EQUAL:
    case OP_NOT_EQUAL:
    case OP_GREATER_THAN:
    case OP_LESS_THAN:
    case OP_LESS_THAN_EQUAL:
    case OP_GREATER_THAN_EQUAL:
    case OP_LOGICAL_AND:
    case OP_LOGICAL_OR:
    case OP_BITWISE_NOT:
    case OP_BITWISE_OR:
    case OP_BITWISE_XOR:
    case OP_BITWISE_AND:
    case OP_SHIFT_LEFT:
    case OP_SHIFT_RIGHT:
    case OP_ASSIGN_EQUAL:
    case OP_ASSIGN_MINUS:
    case OP_ASSIGN_PLUS:
    case OP_ASSIGN_MULT:
    case OP_ASSIGN_DIV:
    case OP_ASSIGN_MODULO:
    case OP_ASSIGN_AND:
    case OP_ASSIGN_OR:
    case OP_ASSIGN_XOR:
    case OP_ASSIGN_SHIFT_LEFT:
    case OP_ASSIGN_SHIFT_RIGHT:
    case OP_COMMA:
        break;
    }

    error(cur_filename, cur_line_num, "invalid oprands to binary operator.");
    return NULL; // Stop compiler warnings.
}

// Check if expression is valid. Return the type.
static DataType *check_expr_type(AstNode *expr)
{
    switch (expr->node_type) {
    case AST_INTEGER_CONST:
        return new_data_type(TYPE_LLONG, 0, 0, 0, NULL, NULL); // TODO: integer suffixes
        break;
    case AST_FLOAT_CONST:
        return new_data_type(TYPE_LDOUBLE, 0, 0, 0, NULL, NULL); // TODO: integer suffixes
        break;
    case AST_STR_LIT:
        return new_data_type(TYPE_POINTER, 0, 0, 0,
                new_data_type(TYPE_CHAR, 0, 0, 0, NULL, NULL), NULL);
        break;
    case AST_IDENTIFIER:
        break;
    case AST_CONDITIONAL_EXPR:
        break;
    case AST_STRUCT_MEMBER_ACCESS:
        break;
    case AST_CAST_EXPR:
        break;
    case AST_BINARY_OP:
        return check_binary_op(expr);
        break;
    case AST_UNARY_OP:
        break;
    default:
        error("--", -1, "internal error: %s: expected an expression node.",
              __func__);
    }
    return NULL; // Stop compiler warnings
}

static AstNode *extract_ident_from_declarator_head(AstNode *declarator_head)
{
    AstNode *ident = new_ast_ident(declarator_head->declarator_head_ident);
    free_ast(declarator_head);
    return ident;
}

static void check_function_specifiers(DataType *type)
{
    // TODO: check that DECL_SPECS does not contain an array.
    // Check storage-class specifiers
    if (type->storage_specs &&
        type->storage_specs != STORAGE_SPEC_STATIC &&
        type->storage_specs != STORAGE_SPEC_EXTERN) {
        error(cur_filename, cur_line_num,
              "invalid storage class specifier for function definition.");
    }
}

static DataType *parse_declaration_specifiers(Vector *decl_specs)
{
    // -1 for unspecified
    int type = -1;
    int is_unsigned = -1;
    int long_cnt = 0;
    int is_short = 0; // 1 if short 0 if not

    int storage_specs = 0;
    int type_qualifiers = 0;

    // Parse the list of types.
    for (int i = 0; i < decl_specs->length; i++) {
        int cur_specifier = *(int *)decl_specs->items[i];

        switch (cur_specifier) {
        case TYPE_INT:
        case TYPE_VOID:
        case TYPE_CHAR:
        case TYPE_FLOAT:
        case TYPE_DOUBLE:
        case TYPE_BOOL:
            if (type > -1)
                error(cur_filename, cur_line_num,
                      "multiple data types in declaration specifiers.");
            else
                type = cur_specifier;
            break;
        case STORAGE_SPEC_TYPEDEF:
        case STORAGE_SPEC_EXTERN:
        case STORAGE_SPEC_STATIC:
        case STORAGE_SPEC_AUTO:
        case STORAGE_SPEC_REGISTER:
            if (storage_specs)
                error(cur_filename, cur_line_num,
                      "multiple storage specifiers in declaration specifiers.");
            else storage_specs = cur_specifier;
            break;
        case TYPE_QUAL_CONST:    type_qualifiers |= TYPE_QUAL_CONST; break;
        case TYPE_QUAL_VOLATILE: type_qualifiers |= TYPE_QUAL_VOLATILE; break;
        case TYPE_QUAL_RESTRICT: type_qualifiers |= TYPE_QUAL_RESTRICT; break;
        case TYPE_SHORT:
            if (is_short)
                error(cur_filename, cur_line_num,
                      "\"short\" appears more than once in declaration "
                      "specifiers.");
            else
                is_short = 1;
            break;
        case TYPE_LONG: long_cnt++; break;
        case TYPE_SIGNED:
            if (is_unsigned == 1) {
                error(cur_filename, cur_line_num,
                      "\"signed\" and \"unsigned\" in declaration specifiers.");
            } else if (is_unsigned == 0) {
                error(cur_filename, cur_line_num,
                      "more than one \"signed\" in declaration specifiers.");
            } else {
                is_unsigned = 0;
            }
            break;
        case TYPE_UNSIGNED:
            if (is_unsigned == 1) {
                error(cur_filename, cur_line_num,
                      "more than one \"unsigned\" in declaration specifiers.");
            } else if (is_unsigned == 0) {
                error(cur_filename, cur_line_num,
                      "\"signed\" and \"unsigned\" in declaration specifiers.");
            } else {
                is_unsigned = 1;
            }
            break;
        }
    }

    // NOTE: This next section of the code is probably the worst code in the
    //       compiler. YOU HAVE BEEN WARNED.

    if (type == -1) {
        if (is_short) {
            type = TYPE_SHORT;
        } else if (long_cnt) {
            type = TYPE_LONG;
        } else if (is_unsigned == 1) {
            type = TYPE_INT;
        } else if (is_unsigned == 0) {
            type = TYPE_INT;
        } else {
            error(cur_filename, cur_line_num,
                  "no type specified in declaration specifiers.");
        }
    }

    if (is_short && type == TYPE_INT) type = TYPE_SHORT;

    if (long_cnt > 2) {
        error(cur_filename, cur_line_num,
              "to many \"long\" types in declaration specifiers.");
    }

    if ((long_cnt || is_short) &&
        (type == TYPE_CHAR || type == TYPE_FLOAT || type == TYPE_BOOL)) {
        error(cur_filename, cur_line_num,
              "cannot specify a size for for \"%s\".",
              type_to_string(new_data_type(type, is_unsigned, storage_specs,
                             type_qualifiers, NULL, NULL)));
    }

    if (type == TYPE_DOUBLE && is_short) {
        error(cur_filename, cur_line_num,
              "\"double\" and \"short\" in function definition.");
    }

    if (is_unsigned > -1 &&
        (type == TYPE_FLOAT || type == TYPE_DOUBLE || type == TYPE_BOOL)) {
        error(cur_filename, cur_line_num,
              "cannot specify a sign for \"%s\".",
              type_to_string(new_data_type(type, is_unsigned, storage_specs,
                             type_qualifiers, NULL, NULL)));
    }

    if (type == TYPE_LONG || type == TYPE_INT) {
        if (long_cnt == 2) {
            type = TYPE_LLONG;
        } else if (long_cnt == 1) {
            type = TYPE_LONG;
        }
    } else if (type == TYPE_DOUBLE) {
        if (long_cnt == 1) {
            type = TYPE_LDOUBLE;
        } else if (long_cnt > 1) {
            error(cur_filename, cur_line_num,
                  "to many \"long\" types for double.");
        }
    }

    return new_data_type(type, is_unsigned == -1 ? 0 : is_unsigned,
                         storage_specs, type_qualifiers, NULL, NULL);
}

}

%syntax_error {
    error(cur_filename, cur_line_num, "unexpected token near \"%s\".",
          cur_tok_str);
}

%parse_accept {
    printf("Parsing done.\n");
}

%parse_failure {
}

%stack_overflow {
    error(cur_filename, cur_line_num, "parser stack overflow.");
}

%code {

extern int yylex();
extern char *yytext;
extern FILE *yyin;
extern int yylineno;
extern void yylex_destroy();

AstNode *parse_c(char *filename)
{
    cur_filename = filename;
    yyin = fopen(filename, "r");
    if (yyin == NULL) error("--", -1, "Failed to open file \"%s\".", filename);

    void *parser = ParseAlloc(malloc_or_die);
    int token_id;

    // Uncomment for debugging
    // ParseTrace(stdout, "Parser: ");

    while ((token_id = yylex())) {
        cur_tok_str = strdup(yytext);
        cur_line_num = yylineno;
        Parse(parser, token_id, cur_tok_str);
    }

    // Cleanup
    Parse(parser, 0, NULL);
    ParseFree(parser, free);
    fclose(yyin);
    yylex_destroy();

    return ast_root_node;
}

}

%token_prefix TOK_
%token_type       { char * }
%token_destructor { free($$); }
%default_type     { AstNode * }

// Define the token "unknown"
%nonassoc UNKNOWN.

%right KWD_IF KWD_ELSE.

program ::= translation_unit(TRANSLATION_UNIT). {
    ast_root_node = TRANSLATION_UNIT;
}

translation_unit(A) ::= external_declaration(EXTERN_DECL). {
    A = malloc_or_die(sizeof(AstNode));
    A->node_type = AST_COMPOUND_STMT;
    A->statements = new_vector();
    vector_append(A->statements, EXTERN_DECL);
}
translation_unit(A) ::= translation_unit(TRANSLATION)
                        external_declaration(EXTERN_DECL). {
    vector_append(TRANSLATION->statements, EXTERN_DECL);
    A = TRANSLATION;
}

external_declaration(A) ::= declaration(DECL).             { A = DECL; }
external_declaration(A) ::= function_definition(FUNC_DEF). { A = FUNC_DEF; }

/* Functions */

function_definition(A) ::= declaration_specs(DECL_SPECS)
                           func_declarator(DECLARATOR)
                           compound_statement(BODY). {
    A = DECLARATOR;

    check_function_specifiers(DECL_SPECS);

    // Check the parameters
    // Void parameters
    if (A->func_params->length == 1 &&
        ((AstNode *)A->func_params->items[0])->decl_declarator == NULL &&
        ((AstNode *)A->func_params->items[0])->decl_type->type == TYPE_VOID) {

        free_ast(((AstNode *)A->func_params->items[0]));
        A->func_params->length = 0;
    } else {
        for (int i = 0; i < A->func_params->length; i++) {
            if (((AstNode *)A->func_params->items[i])->decl_declarator == NULL)
                error(cur_filename, cur_line_num, "parameter name omitted.");
        }
    }

    // Set the function return type
    // Function returning pointer
    if (A->func_type != NULL)
        set_pointer_type(A->func_type, DECL_SPECS);
    else
        A->func_type = DECL_SPECS;

    A->func_body = BODY;
}
function_definition(A) ::= declaration_specs(DECL_SPECS)
                           old_func_declarator(DECLARATOR)
                           declaration_list(DECLARATION_LIST)
                           compound_statement(BODY). {
    check_function_specifiers(DECL_SPECS);

    A = DECLARATOR;
    if (A->func_params->length != DECLARATION_LIST->length) {
        error(cur_filename, cur_line_num, "length of parameter in function "
              "declarator does not match the length of the parameters in the "
              "declaration list.");
    } else {
        for (int i = 0; i < DECLARATION_LIST->length; i++) {
            // Check that the identifiers match
            if (strcmp(((AstNode *)DECLARATION_LIST->items[i])->decl_declarator
                ->identifier,
                ((char *)A->func_params->items[i])) != 0) {
                error(cur_filename, cur_line_num, "identifiers do not match in "
                      "function definition.");
            }
        }
    }

    // Function returning pointer
    if (A->func_type != NULL)
        set_pointer_type(A->func_type, DECL_SPECS);
    else
        A->func_type = DECL_SPECS;

    A->func_params = DECLARATION_LIST;
    A->func_body = BODY;
}

/* Function declarators */

func_declarator(A) ::= direct_declarator_head(HEAD)
                       func_direct_declarator_tail(TAIL). {
    A = HEAD;
    A->node_type = AST_FUNCTION_DEF;
    A->func_params = TAIL->func_params;
    free(TAIL);
}

// Tail
func_direct_declarator_tail(A) ::= LPAREN parameter_type_list(PARAMS) RPAREN. {
    A = malloc_or_die(sizeof(AstNode));
    A->node_type = AST_FUNCTION_DEF;
    A->func_params = PARAMS;
}
func_direct_declarator_tail(A) ::= LPAREN RPAREN. {
    A = malloc_or_die(sizeof(AstNode));
    A->node_type = AST_FUNCTION_DEF;
    A->func_params = new_vector();
}

// Old style function declarator
old_func_declarator(A) ::= direct_declarator_head(HEAD)
                           old_func_direct_declarator_tail(TAIL). {
    A = HEAD;
    A->node_type = AST_FUNCTION_DEF;
    A->func_ident = HEAD->identifier;
    A->func_params = TAIL;
}

// Old style tail
%type old_func_direct_declarator_tail { Vector * }
old_func_direct_declarator_tail(A) ::= LPAREN identifier_list(IDENT_LIST)
                                       RPAREN. {
    A = IDENT_LIST;
}

/* Declarations */

declaration(A) ::= declaration_specs(DECL_SPECS)
                   init_declarator_list(INIT_DECL_LIST) SEMICOLON. {
    for (int i = 0; i < INIT_DECL_LIST->length; i++) {
        AstNode *declaration = ((AstNode *)INIT_DECL_LIST->items[i]);

        // Function declarator
        if (declaration->node_type == AST_FUNC_DECLARATION) {
            check_function_specifiers(DECL_SPECS);

            // Function returning a pointer
            if (declaration->func_type != NULL) {
                DataType *pointer_type = malloc_or_die(sizeof(DataType));
                memcpy(pointer_type, DECL_SPECS, sizeof(DataType));

                set_pointer_type(declaration->func_type, pointer_type);
            } else {
                declaration->func_type = malloc_or_die(sizeof(DataType));
                memcpy(declaration->func_type, DECL_SPECS, sizeof(DataType));
            }

        // Typedef
        } else if (DECL_SPECS->storage_specs == STORAGE_SPEC_TYPEDEF) {
            if (declaration->decl_initializer != NULL)
                error(cur_filename, cur_line_num,
                      "typedef must not contain an initializer.");

            declaration->node_type = AST_TYPEDEF;
            declaration->decl_type = malloc_or_die(sizeof(DataType));

            // Pointer
            if (declaration->decl_declarator->declarator_head_pointer != NULL) {
                memcpy(declaration->decl_type,
                       declaration->decl_declarator->declarator_head_pointer,
                       sizeof(DataType));
                DataType *pointer_type = malloc_or_die(sizeof(DataType));
                memcpy(pointer_type, DECL_SPECS, sizeof(DataType));
                set_pointer_type(declaration->decl_type, pointer_type);
            // Non-pointer typedef
            } else {
                memcpy(declaration->decl_type, DECL_SPECS, sizeof(DataType));
            }

            declaration->decl_declarator =
                extract_ident_from_declarator_head(declaration->decl_declarator);
        // Normal variable declaration
        } else {
            // If it is a pointer
            if (declaration->decl_declarator->declarator_head_pointer != NULL) {
                DataType *pointer_type = malloc_or_die(sizeof(DataType));
                memcpy(pointer_type, DECL_SPECS, sizeof(DataType));

                set_pointer_type(declaration->decl_declarator->
                                 declarator_head_pointer, pointer_type);

                // Remove the pointer from the declarator head
                declaration->decl_type = declaration->decl_declarator->
                                         declarator_head_pointer;

                // TODO: try and replace this code with
                //       extract_ident_from_declarator_head
                char *ident = strdup(declaration->decl_declarator->
                                     declarator_head_ident);
                free(declaration->decl_declarator->declarator_head_ident);
                free(declaration->decl_declarator);
                declaration->decl_declarator = new_ast_ident(ident);
                free(ident);
            } else {
                // Normal vaiable declaration
                declaration->decl_type = malloc_or_die(sizeof(DataType));
                memcpy(declaration->decl_type, DECL_SPECS, sizeof(DataType));

                declaration->decl_declarator =
                extract_ident_from_declarator_head(declaration->decl_declarator);
            }
        }
    }

    free_data_type(DECL_SPECS);

    if (INIT_DECL_LIST->length > 1) {
        A = malloc_or_die(sizeof(AstNode));
        A->node_type = AST_DECL_LIST;
        A->decl_list = INIT_DECL_LIST;
    } else {
        A = INIT_DECL_LIST->items[0];
        vector_free(INIT_DECL_LIST);
    }
}
declaration ::= declaration_specs SEMICOLON. {
    warning(cur_filename, cur_line_num,
            "declaration does not declare anything.");
}

%type declaration_list { Vector * }
declaration_list(A) ::= declaration(DECL). {
    A = new_vector();
    vector_append(A, DECL);
}
declaration_list(A) ::= declaration_list(LIST) declaration(NEW_DECL). {
    vector_append(LIST, NEW_DECL);
    A = LIST;
}

// Init declarator
%type init_declarator_list { Vector * }
init_declarator_list(A) ::= init_declarator(DECL). {
    A = new_vector();
    vector_append(A, DECL);
}
init_declarator_list(A) ::= init_declarator_list(DECL_LIST) COMMA
                            init_declarator(NEW_DECL). {
    vector_append(DECL_LIST, NEW_DECL);
    A = DECL_LIST;
}

init_declarator(A) ::= declarator(DECL). {
    if (DECL->node_type == AST_FUNC_DECLARATION)
        A = DECL;
    else
        A = new_ast_declaration(NULL, DECL, NULL);
}
init_declarator(A) ::= declarator(DECL) OP_EQUALS initializer(INIT). {
    if (DECL->node_type == AST_FUNC_DECLARATION)
        error(cur_filename, cur_line_num,
              "function \"%s\" initialized like a variable.");
    A = new_ast_declaration(NULL, DECL, INIT);
}

// Declaration specifiers
%type declaration_specs { DataType * }
declaration_specs(A) ::= declaration_specs_list(TYPE_LIST). {
    A = parse_declaration_specifiers(TYPE_LIST);

    // Free TYPE_LIST
    for (int i = 0; i < TYPE_LIST->length; i++)
        free(TYPE_LIST->items[i]);
    vector_free(TYPE_LIST);
}

// Storage class specifiers
%type declaration_specs_list { Vector * }
declaration_specs_list(A) ::= storage_class_specifier(SPEC). {
    A = new_vector();
    int *new_spec = malloc_or_die(sizeof(int));
    *new_spec = SPEC;
    vector_append(A, (void *)new_spec);
}
declaration_specs_list(A) ::= storage_class_specifier(SPEC)
                              declaration_specs_list(DECL_SPECS). {
    int *new_spec = malloc_or_die(sizeof(int));
    *new_spec = SPEC;
    vector_append(DECL_SPECS, (void *)new_spec);
    A = DECL_SPECS;
}

// Type specifiers
declaration_specs_list(A) ::= type_specifier(TYPE). {
    int *new_type = malloc_or_die(sizeof(int));
    *new_type = TYPE;
    A = new_vector();
    vector_append(A, (void *)new_type);
}
declaration_specs_list(A) ::= type_specifier(TYPE)
                              declaration_specs_list(DECL_SPECS). {
    int *new_type = malloc_or_die(sizeof(int));
    *new_type = TYPE;
    vector_append(DECL_SPECS, (void *)new_type);
    A = DECL_SPECS;
}

// Type qualifiers
declaration_specs_list(A) ::= type_qualifier(TYPE_QUAL). {
    int *new_qual = malloc_or_die(sizeof(int));
    *new_qual = TYPE_QUAL;
    A = new_vector();
    vector_append(A, (void *)new_qual);
}
declaration_specs_list(A) ::= type_qualifier(TYPE_QUAL)
                              declaration_specs_list(DECL_SPECS). {
    int *new_qual = malloc_or_die(sizeof(int));
    *new_qual = TYPE_QUAL;
    vector_append(DECL_SPECS, (void *)new_qual);
    A = DECL_SPECS;
}
declaration_specs_list ::= KWD_INLINE.
declaration_specs_list ::= KWD_INLINE declaration_specs_list.

%type storage_class_specifier { int }
storage_class_specifier(A) ::= KWD_TYPEDEF. { A = STORAGE_SPEC_TYPEDEF; }
storage_class_specifier(A) ::= KWD_EXTERN.  { A = STORAGE_SPEC_EXTERN; }
storage_class_specifier(A) ::= KWD_STATIC.  { A = STORAGE_SPEC_STATIC; }
storage_class_specifier(A) ::= KWD_AUTO.    { A = STORAGE_SPEC_AUTO; }
storage_class_specifier(A) ::= KWD_REGISTER. {
    A = STORAGE_SPEC_REGISTER;
    warning(cur_filename, cur_line_num, "register keyword is not supported.");
}

%type specifier_qualifier_list { Vector * }
specifier_qualifier_list(A) ::= type_specifier(TYPE). {
    A = new_vector();
    int *new_type = malloc_or_die(sizeof(int));
    *new_type = TYPE;
    vector_append(A, (void *)new_type);
}
specifier_qualifier_list(A) ::= type_specifier(TYPE)
                                specifier_qualifier_list(LIST). {
    int *new_type = malloc_or_die(sizeof(int));
    *new_type = TYPE;
    vector_append(LIST, new_type);
    A = LIST;
}
specifier_qualifier_list(A) ::= type_qualifier(QUAL). {
    A = new_vector();
    int *new_qual = malloc_or_die(sizeof(int));
    *new_qual = QUAL;
    vector_append(A, (void *)new_qual);
}
specifier_qualifier_list(A) ::= type_qualifier(QUAL)
                                specifier_qualifier_list(LIST). {
    int *new_qual= malloc_or_die(sizeof(int));
    *new_qual = QUAL;
    vector_append(LIST, new_qual);
    A = LIST;
}

// Type specifiers
%type type_specifier { int }
type_specifier(A) ::= KWD_VOID.     { A = TYPE_VOID; }
type_specifier(A) ::= KWD_CHAR.     { A = TYPE_CHAR; }
type_specifier(A) ::= KWD_SHORT.    { A = TYPE_SHORT; }
type_specifier(A) ::= KWD_LONG.     { A = TYPE_LONG; }
type_specifier(A) ::= KWD_INT.      { A = TYPE_INT; }
type_specifier(A) ::= KWD_FLOAT.    { A = TYPE_FLOAT; }
type_specifier(A) ::= KWD_DOUBLE.   { A = TYPE_DOUBLE; }
type_specifier(A) ::= KWD_SIGNED.   { A = TYPE_SIGNED; }
type_specifier(A) ::= KWD_UNSIGNED. { A = TYPE_UNSIGNED; }
type_specifier(A) ::= KWD_BOOL.     { A = TYPE_BOOL; }
type_specifier ::= KWD_IMAGINARY. {
    error(cur_filename, cur_line_num, "complex types not supported.");
}
type_specifier ::= KWD_COMPLEX. {
    error(cur_filename, cur_line_num, "complex types not supported.");
}
type_specifier ::= TYPEDEF_NAME. // TODO
type_specifier ::= struct_or_union_specifier. // TODO
type_specifier ::= enum_specifier. // TODO

// Structs
struct_or_union_specifier ::= struct_or_union IDENT LBRACE
                              struct_declaration_list RBRACE.
struct_or_union_specifier ::= struct_or_union LBRACE struct_declaration_list
                              RBRACE.
struct_or_union_specifier ::= struct_or_union IDENT.

struct_or_union ::= KWD_STRUCT.
struct_or_union ::= KWD_UNION.

struct_declaration_list ::= struct_declaration.
struct_declaration_list ::= struct_declaration_list struct_declaration.

struct_declaration ::= specifier_qualifier_list struct_declarator_list
                       SEMICOLON.

struct_declarator_list ::= struct_declarator.
struct_declarator_list ::= struct_declarator_list COMMA struct_declarator.

struct_declarator ::= declarator.
struct_declarator ::= COLON constant_expr.
struct_declarator ::= declarator COLON constant_expr.

// Enums
enum_specifier ::= KWD_ENUM LBRACE enumerator_list RBRACE.
enum_specifier ::= KWD_ENUM IDENT LBRACE enumerator_list RBRACE.
enum_specifier ::= KWD_ENUM LBRACE enumerator_list COMMA RBRACE.
enum_specifier ::= KWD_ENUM IDENT LBRACE enumerator_list COMMA RBRACE.
enum_specifier ::= KWD_ENUM IDENT.

enumerator_list ::= enumerator.
enumerator_list ::= enumerator_list COMMA enumerator.

enumerator ::= ENUMERATION_CONSTANT.
enumerator ::= ENUMERATION_CONSTANT OP_EQUALS constant_expr.

/* Declarator */

declarator(A) ::= direct_declarator_head(HEAD) direct_declarator_tail(TAIL). {
    // If it is a funciton def merge the head and tail into one AST node.
    if (TAIL->node_type == AST_FUNCTION_DEF) {
        A = TAIL;
        A->node_type = AST_FUNC_DECLARATION;
        A->func_ident = HEAD->identifier;
        // Function returning a pointer
        if (HEAD->declarator_head_pointer != NULL)
            A->func_type = HEAD->declarator_head_pointer;
        else
            A->func_type = NULL;
        free(HEAD);
        A->func_body = NULL;

    // Arrays
    } else if (TAIL->node_type == AST_DATA_TYPE) {
        A = HEAD;

        // If the head contains a pointer
        if (A->declarator_head_pointer != NULL)
            set_pointer_type(A->declarator_head_pointer, TAIL->data_type);
        else
            A->declarator_head_pointer = TAIL->data_type;
        free(TAIL);
    }
}
declarator(A) ::= direct_declarator_head(HEAD). { A = HEAD; }

// Direct declarator head
direct_declarator_head(A) ::= direct_declarator_head_no_pointer(HEAD). {
    A = HEAD;
}
direct_declarator_head(A) ::= pointer(POINTER)
                              direct_declarator_head_no_pointer(HEAD). {
    HEAD->declarator_head_pointer = POINTER;
    A = HEAD;
}

direct_declarator_head_no_pointer(A) ::= IDENT(IDENT). {
    A = malloc_or_die(sizeof(AstNode));
    A->node_type = AST_DECLARATOR_HEAD;
    A->declarator_head_ident = IDENT;
    A->declarator_head_pointer = NULL;
}
direct_declarator_head_no_pointer(A) ::= LPAREN direct_declarator_head(HEAD)
                                         RPAREN. {
    A = HEAD;
}

// Direct declarator tail
direct_declarator_tail(A) ::= array_declarator_tail(ARRAY).      { A = ARRAY; }
direct_declarator_tail(A) ::= func_direct_declarator_tail(TAIL). { A = TAIL; }
direct_declarator_tail ::= old_func_direct_declarator_tail. {
    error(cur_filename, cur_line_num,
          "a parameter list without types is only allowed in a function "
          "definition");
}

// Arrays

array_declarator_tail(A) ::= array_declarator_single(ARRAY). { A = ARRAY; }
// Multi-dimensional arrays
array_declarator_tail(A) ::= array_declarator_tail(ARRAY)
                             array_declarator_single(NEW_DIMENSION). {
    set_pointer_type(ARRAY->data_type, NEW_DIMENSION->data_type);
    free(NEW_DIMENSION);
    A = ARRAY;
}

array_declarator_single(A) ::= LSQUARE assignment_expr(EXPR) RSQUARE. {
    A = new_ast_data_type(new_data_type(TYPE_ARRAY, 0, 0, 0, NULL, EXPR));
}
array_declarator_single(A) ::= LSQUARE RSQUARE. {
    A = new_ast_data_type(new_data_type(TYPE_ARRAY, 0, 0, 0, NULL, NULL));
}
array_declarator_single ::= LSQUARE type_qualifier_list assignment_expr
                            RSQUARE.
array_declarator_single ::= LSQUARE type_qualifier_list RSQUARE.
array_declarator_single ::= LSQUARE KWD_STATIC assignment_expr RSQUARE.
array_declarator_single ::= LSQUARE KWD_STATIC type_qualifier_list
                            assignment_expr RSQUARE.
array_declarator_single ::= LSQUARE type_qualifier_list KWD_STATIC
                            assignment_expr RSQUARE.
array_declarator_single ::= LSQUARE OP_ASTERISK RSQUARE.
array_declarator_single ::= LSQUARE type_qualifier_list OP_ASTERISK RSQUARE.

// Pointers
%type pointer { DataType * }
pointer(A) ::= OP_ASTERISK. {
    A = new_data_type(TYPE_POINTER, 0, 0, 0, NULL, NULL);
}
pointer(A) ::= OP_ASTERISK type_qualifier_list(QUALIFERS). {
    A = new_data_type(TYPE_POINTER, 0, 0, QUALIFERS, NULL, NULL);
}
pointer(A) ::= OP_ASTERISK pointer(POINTER). {
    A = new_data_type(TYPE_POINTER, 0, 0, 0, POINTER, NULL);
}
pointer(A) ::= OP_ASTERISK type_qualifier_list(QUALIFIERS) pointer(POINTER). {
    A = new_data_type(TYPE_POINTER, 0, 0, QUALIFIERS, POINTER, NULL);
}

// Type qualifiers
%type type_qualifier_list { int }
type_qualifier_list(A) ::= type_qualifier(QUALIFIER). { A = QUALIFIER; }
type_qualifier_list(A) ::= type_qualifier_list(QUALIFIERS)
                           type_qualifier(NEW_QUALIFIER). {
    A = QUALIFIERS | NEW_QUALIFIER;
}

%type type_qualifier { int }
type_qualifier(A) ::= KWD_CONST.    { A = TYPE_QUAL_CONST; }
type_qualifier(A) ::= KWD_RESTRICT. { A = TYPE_QUAL_RESTRICT; }
type_qualifier(A) ::= KWD_VOLATILE. { A = TYPE_QUAL_VOLATILE; }

// Parameters
%type parameter_type_list { Vector * }
parameter_type_list(A) ::= parameter_list(PARAMS). { A = PARAMS; }
parameter_type_list ::= parameter_list COMMA ELLIPSIS. // TODO

%type parameter_list { Vector * }
parameter_list(A) ::= parameter_declaration(PARAM). {
    A = new_vector();
    vector_append(A, PARAM);
}
parameter_list(A) ::= parameter_list(PARAM_LIST) COMMA
                      parameter_declaration(NEW_PARAM). {
    vector_append(PARAM_LIST, NEW_PARAM);
    A = PARAM_LIST;
}

parameter_declaration(A) ::= declaration_specs(DECL_SPECS). {
    A = new_ast_declaration(DECL_SPECS, NULL, NULL);
}
parameter_declaration(A) ::= declaration_specs(DECL_SPECS)
                             declarator(DECLARATOR). {
    DECLARATOR = extract_ident_from_declarator_head(DECLARATOR);
    A = new_ast_declaration(DECL_SPECS, DECLARATOR, NULL);
}

// Type name
%type type_name { DataType * }
type_name(A) ::= specifier_qualifier_list(SPEC_QUAL_LIST). {
    A = parse_declaration_specifiers(SPEC_QUAL_LIST);

    // Free SPEC_QUAL_LIST
    for (int i = 0; i < SPEC_QUAL_LIST->length; i++)
        free(SPEC_QUAL_LIST->items[i]);
    vector_free(SPEC_QUAL_LIST);
}
type_name ::= specifier_qualifier_list abstract_declarator. // TODO

// Direct abstract declarator
direct_abstract_declarator ::= LPAREN abstract_declarator RPAREN.
direct_abstract_declarator ::= LSQUARE RSQUARE.
direct_abstract_declarator ::= LSQUARE assignment_expr RSQUARE.
direct_abstract_declarator ::= direct_abstract_declarator LSQUARE RSQUARE.
direct_abstract_declarator ::= direct_abstract_declarator LSQUARE
                               assignment_expr RSQUARE.
direct_abstract_declarator ::= direct_abstract_declarator LSQUARE OP_ASTERISK
                               RSQUARE.
direct_abstract_declarator ::= LSQUARE OP_ASTERISK RSQUARE.
direct_abstract_declarator ::= LPAREN RPAREN.
direct_abstract_declarator ::= LPAREN parameter_type_list RPAREN.
direct_abstract_declarator ::= direct_abstract_declarator LPAREN RPAREN.
direct_abstract_declarator ::= direct_abstract_declarator LPAREN
                               parameter_type_list RPAREN.

abstract_declarator ::= pointer.
abstract_declarator ::= direct_abstract_declarator.
abstract_declarator ::= pointer direct_abstract_declarator.

// Identifier list
%type identifier_list { Vector * }
identifier_list(A) ::= IDENT(IDENT). {
    A = new_vector();
    vector_append(A, IDENT);
}
identifier_list(A) ::= identifier_list(LIST) COMMA IDENT(IDENT). {
    vector_append(LIST, IDENT);
    A = LIST;
}

// Initializer
initializer ::= assignment_expr.
initializer ::= LBRACE initializer_list RBRACE.
initializer ::= LBRACE initializer_list COMMA RBRACE.

initializer_list ::= initializer.
initializer_list ::= designation initializer.
initializer_list ::= initializer_list COMMA initializer.
initializer_list ::= initializer_list COMMA designation initializer.

// Designation
designation ::= designator_list OP_EQUALS.

designator_list ::= designator.
designator_list ::= designator_list designator.

designator ::= LSQUARE constant_expr RSQUARE.
designator ::= DOT IDENT.

/* Statements */

statement(A) ::= labeled_statement(STMT).    { A = STMT; }
statement(A) ::= compound_statement(STMT).   { A = STMT; }
statement(A) ::= expression_statement(STMT). { A = STMT; }
statement(A) ::= selection_statement(STMT).  { A = STMT; }
statement(A) ::= iteration_statement(STMT).  { A = STMT; }
statement(A) ::= jump_statement(STMT).       { A = STMT; }

// Labeled statement
labeled_statement(A) ::= IDENT(IDENT) COLON statement(STMT). {
    A = malloc_or_die(sizeof(AstNode));
    A->node_type = AST_LABEL_STMT;
    A->label_ident = IDENT;
    A->label_stmt = STMT;
}
labeled_statement(A) ::= KWD_CASE constant_expr(EXPR) COLON statement(STMT). {
    A = new_ast_conditional(AST_CASE_STMT, EXPR, STMT, NULL);
}
labeled_statement(A) ::= KWD_DEFAULT COLON statement(STMT). {
    A = malloc_or_die(sizeof(AstNode));
    A->node_type = AST_DEFAULT_STMT;
    A->default_stmt = STMT;
}

// Compound statement
compound_statement(A) ::= LBRACE RBRACE. {
    A = malloc_or_die(sizeof(AstNode));
    A->node_type = AST_COMPOUND_STMT;
    A->statements = new_vector();
}
compound_statement(A) ::= LBRACE block_item_list(BLOCK_ITEM_LIST) RBRACE. {
    A = BLOCK_ITEM_LIST;
}

block_item_list(A) ::= block_item(ITEM). {
    A = malloc_or_die(sizeof(AstNode));
    A->node_type = AST_COMPOUND_STMT;
    A->statements = new_vector();
    if (ITEM != NULL)
        vector_append(A->statements, ITEM);
}
block_item_list(A) ::= block_item_list(ITEM_LIST) block_item(NEW_ITEM). {
    if (NEW_ITEM != NULL)
        vector_append(ITEM_LIST->statements, NEW_ITEM);
    A = ITEM_LIST;
}

block_item(A) ::= declaration(DECL). { A = DECL; }
block_item(A) ::= statement(STMT).   { A = STMT; }

// Expr statement
expression_statement(A) ::= expression(EXPR) SEMICOLON. {
    A = new_ast_expr_stmt(EXPR);
}
expression_statement(A) ::= SEMICOLON. { A = NULL; }

// If else
selection_statement(A) ::= KWD_IF LPAREN expression(COND) RPAREN
                           statement(BODY). [KWD_ELSE] {
    A = new_ast_conditional(AST_IF_STMT, COND, BODY, NULL);

    // Check the expression
    if (!is_scalar_type(check_expr_type(COND))) {
        error(cur_filename, cur_line_num,
              "invalid expression in if statement, expected a scalar type.");
    }
}
selection_statement(A) ::= KWD_IF LPAREN expression(COND) RPAREN statement(BODY)
                           KWD_ELSE statement(ELSE). {
    A = new_ast_conditional(AST_IF_STMT, COND, BODY, ELSE);

    // Check the expression
    if (!is_scalar_type(check_expr_type(COND))) {
        error(cur_filename, cur_line_num,
              "invalid expression in if statement, expected a scalar type.");
    }
}

// Switch statement
selection_statement(A) ::= KWD_SWITCH LPAREN expression(EXPR) RPAREN
                           statement(BODY). {
    A = new_ast_conditional(AST_SWITCH_STMT, EXPR, BODY, NULL);
}

// While and do while
iteration_statement(A) ::= KWD_WHILE LPAREN expression(COND) RPAREN
                           statement(BODY). {
    A = new_ast_conditional(AST_WHILE_STMT, COND, BODY, NULL);
}
iteration_statement(A) ::= KWD_DO statement(BODY) KWD_WHILE LPAREN
                           expression(COND) RPAREN SEMICOLON. {
    A = new_ast_conditional(AST_DO_WHILE_STMT, COND, BODY, NULL);
}

// For loop
iteration_statement(A) ::= KWD_FOR LPAREN expression_statement(EXPR1)
                           expression_statement(EXPR2) expression(EXPR3) RPAREN
                           statement(BODY). {
    A = new_ast_for_loop(EXPR1, EXPR2, new_ast_expr_stmt(EXPR3), BODY);
}
iteration_statement(A) ::= KWD_FOR LPAREN expression_statement(EXPR1)
                           expression_statement(EXPR2) RPAREN statement(BODY). {
    A = new_ast_for_loop(EXPR1, EXPR2, NULL, BODY);
}
iteration_statement(A) ::= KWD_FOR LPAREN declaration(DECL)
                           expression_statement(EXPR2) expression(EXPR3) RPAREN
                           statement(BODY). {
    A = new_ast_for_loop(DECL, EXPR2, new_ast_expr_stmt(EXPR3), BODY);
}
iteration_statement(A) ::= KWD_FOR LPAREN declaration(DECL)
                           expression_statement(EXPR2) RPAREN statement(BODY). {
    A = new_ast_for_loop(DECL, EXPR2, NULL, BODY);
}

// Jump statements
jump_statement(A) ::= KWD_GOTO IDENT(IDENT) SEMICOLON. {
    A = malloc_or_die(sizeof(AstNode));
    A->node_type = AST_GOTO_STMT;
    A->identifier = IDENT;
}
jump_statement(A) ::= KWD_CONTINUE SEMICOLON. {
    A = malloc_or_die(sizeof(AstNode));
    A->node_type = AST_CONTINUE_STMT;
}
jump_statement(A) ::= KWD_BREAK SEMICOLON. {
    A = malloc_or_die(sizeof(AstNode));
    A->node_type = AST_BREAK_STMT;
}
jump_statement(A) ::= KWD_RETURN SEMICOLON. {
    A = malloc_or_die(sizeof(AstNode));
    A->node_type = AST_RETURN_STMT;
    A->expression = NULL;
}
jump_statement(A) ::= KWD_RETURN expression(EXPR) SEMICOLON. {
    A = malloc_or_die(sizeof(AstNode));
    A->node_type = AST_RETURN_STMT;
    A->expression = EXPR;
}

/* Expressions */

constant_expr(A) ::= conditional_expr(COND). { A = COND; }

expression(A) ::= assignment_expr(ASSIGNMENT). { A = ASSIGNMENT; }
expression(A) ::= expression(LHS) COMMA assignment_expr(RHS). {
    A = new_ast_binary_op(OP_COMMA, LHS, RHS);
}

// Assignment operators
%type assignment_op { int }
assignment_op(A) ::= OP_EQUALS.             { A = OP_ASSIGN_EQUAL; }
assignment_op(A) ::= OP_TIMES_EQUALS.       { A = OP_ASSIGN_MULT; }
assignment_op(A) ::= OP_DIVIDE_EQUALS.      { A = OP_ASSIGN_DIV; }
assignment_op(A) ::= OP_MODULO_EQUALS.      { A = OP_ASSIGN_MODULO; }
assignment_op(A) ::= OP_PLUS_EQUALS.        { A = OP_ASSIGN_PLUS; }
assignment_op(A) ::= OP_MINUS_EQUALS.       { A = OP_ASSIGN_MINUS; }
assignment_op(A) ::= OP_SHIFT_LEFT_EQUALS.  { A = OP_ASSIGN_SHIFT_LEFT; }
assignment_op(A) ::= OP_SHIFT_RIGHT_EQUALS. { A = OP_ASSIGN_SHIFT_RIGHT; }
assignment_op(A) ::= OP_AND_EQUALS.         { A = OP_ASSIGN_AND; }
assignment_op(A) ::= OP_XOR_EQUALS.         { A = OP_ASSIGN_XOR; }
assignment_op(A) ::= OP_OR_EQUALS.          { A = OP_ASSIGN_OR; }

// Assignment expression
assignment_expr(A) ::= conditional_expr(COND). { A = COND; }
assignment_expr(A) ::= unary_expr(UNARY) assignment_op(OP)
                       assignment_expr(ASSIGN). {
    A = new_ast_binary_op(OP, UNARY, ASSIGN);
}

conditional_expr(A) ::= logical_or_expr(LOGICAL_OR). { A = LOGICAL_OR; }
conditional_expr(A) ::= logical_or_expr(COND) QUESTION_MARK expression(BODY)
                        COLON conditional_expr(ELSE_BODY). {
    A = new_ast_conditional(AST_CONDITIONAL_EXPR, COND, BODY, ELSE_BODY);
}

logical_or_expr(A) ::= logical_and_expr(LOGICAL_AND). { A = LOGICAL_AND; }
logical_or_expr(A) ::= logical_or_expr(LHS) OP_LOGICAL_OR
                       logical_and_expr(RHS). {
    A = new_ast_binary_op(OP_LOGICAL_OR, LHS, RHS);
}

logical_and_expr(A) ::= inclusive_or_expr(INCLUSIVE). { A = INCLUSIVE; }
logical_and_expr(A) ::= logical_and_expr(LHS) OP_LOGICAL_AND
                        inclusive_or_expr(RHS). {
    A = new_ast_binary_op(OP_LOGICAL_AND, LHS, RHS);
}

inclusive_or_expr(A) ::= exclusive_or_expr(EXCLUSIVE). { A = EXCLUSIVE; }
inclusive_or_expr(A) ::= inclusive_or_expr(LHS) OP_OR exclusive_or_expr(RHS). {
    A = new_ast_binary_op(OP_BITWISE_OR, LHS, RHS);
}

exclusive_or_expr(A) ::= and_expr(AND). { A = AND; }
exclusive_or_expr(A) ::= exclusive_or_expr(LHS) OP_CARET and_expr(RHS). {
    A = new_ast_binary_op(OP_BITWISE_XOR, LHS, RHS);
}

and_expr(A) ::= equality_expr(EQUALITY). { A = EQUALITY; }
and_expr(A) ::= and_expr(LHS) OP_AND equality_expr(RHS). {
    A = new_ast_binary_op(OP_BITWISE_AND, LHS, RHS);
}

// Equality check
equality_expr(A) ::= relational_expr(RELATIONAL). { A = RELATIONAL; }
equality_expr(A) ::= equality_expr(LHS) OP_EQUALITY relational_expr(RHS). {
    A = new_ast_binary_op(OP_EQUAL, LHS, RHS);
}
equality_expr(A) ::= equality_expr(LHS) OP_NOT_EQUAL relational_expr(RHS). {
    A = new_ast_binary_op(OP_NOT_EQUAL, LHS, RHS);
}

// Realational expressions
relational_expr(A) ::= shift_expr(SHIFT). { A = SHIFT; }
relational_expr(A) ::= relational_expr(LHS) OP_LESS_THAN shift_expr(RHS). {
    A = new_ast_binary_op(OP_LESS_THAN, LHS, RHS);
}
relational_expr(A) ::= relational_expr(LHS) OP_GREATER_THAN shift_expr(RHS). {
    A = new_ast_binary_op(OP_GREATER_THAN, LHS, RHS);
}
relational_expr(A) ::= relational_expr(LHS) OP_LESS_THAN_OR_EQUAL
                       shift_expr(RHS). {
    A = new_ast_binary_op(OP_LESS_THAN_EQUAL, LHS, RHS);
}
relational_expr(A) ::= relational_expr(LHS) OP_GREATER_THAN_OR_EQUAL
                       shift_expr(RHS). {
    A = new_ast_binary_op(OP_GREATER_THAN_EQUAL, LHS, RHS);
}

// Shift expression
shift_expr(A) ::= additive_expr(ADD).  { A = ADD; }
shift_expr(A) ::= shift_expr(LHS) OP_SHIFT_LEFT additive_expr(RHS). {
    A = new_ast_binary_op(OP_SHIFT_LEFT, LHS, RHS);
}
shift_expr(A) ::= shift_expr(LHS) OP_SHIFT_RIGHT additive_expr(RHS). {
    A = new_ast_binary_op(OP_SHIFT_RIGHT, LHS, RHS);
}

// Addition
additive_expr(A) ::= multiplicative_expr(MULT_EXPR). { A = MULT_EXPR; }
additive_expr(A) ::= additive_expr(LHS) OP_PLUS multiplicative_expr(RHS). {
    A = new_ast_binary_op(OP_PLUS, LHS, RHS);
    check_binary_op(A);
}
additive_expr(A) ::= additive_expr(LHS) OP_MINUS multiplicative_expr(RHS). {
    A = new_ast_binary_op(OP_MINUS, LHS, RHS);
    check_binary_op(A);
}

// Multiplication
multiplicative_expr(A) ::= cast_expr(CAST). { A = CAST; }
multiplicative_expr(A) ::= multiplicative_expr(LHS) OP_ASTERISK
                           cast_expr(RHS). {
    A = new_ast_binary_op(OP_MULT, LHS, RHS);
}
multiplicative_expr(A) ::= multiplicative_expr(LHS) OP_DIVIDE cast_expr(RHS). {
    A = new_ast_binary_op(OP_DIV, LHS, RHS);
}
multiplicative_expr(A) ::= multiplicative_expr(LHS) OP_MODULO cast_expr(RHS). {
    A = new_ast_binary_op(OP_MODULO, LHS, RHS);
}

cast_expr(A) ::= unary_expr(UNARY). { A = UNARY; }
cast_expr(A) ::= LPAREN type_name(TYPE) RPAREN cast_expr(EXPR). {
    A = malloc_or_die(sizeof(AstNode));
    A->node_type = AST_CAST_EXPR;
    A->cast_type = TYPE;
    A->cast_expr = EXPR;
}

%type unary_op { int }
unary_op(A) ::= OP_AND.      { A = UNARY_ADDRESS; }
unary_op(A) ::= OP_ASTERISK. { A = UNARY_DEREF; }
unary_op(A) ::= OP_PLUS.     { A = UNARY_PLUS; }
unary_op(A) ::= OP_MINUS.    { A = UNARY_MINUS; }
unary_op(A) ::= OP_TILDE.    { A = UNARY_BITWISE_NOT; }
unary_op(A) ::= OP_NOT.      { A = UNARY_NOT; }

unary_expr(A) ::= postfix_expr(POSTFIX). { A = POSTFIX; }
unary_expr(A) ::= OP_PLUS_PLUS unary_expr(EXPR). {
    A = new_ast_unary_op(UNARY_INC, EXPR);
}
unary_expr(A) ::= OP_MINUS_MINUS unary_expr(EXPR). {
    A = new_ast_unary_op(UNARY_DEC, EXPR);
}
unary_expr(A) ::= unary_op(OP) cast_expr(EXPR). {
    A = new_ast_unary_op(OP, EXPR);
}
unary_expr(A) ::= OP_SIZEOF unary_expr(EXPR). {
    A = new_ast_unary_op(UNARY_SIZEOF, EXPR);
}
unary_expr(A) ::= OP_SIZEOF LPAREN type_name RPAREN. {
    // TODO: Finish this. Calculate type size.
    A = new_ast_unary_op(UNARY_SIZEOF, NULL);
}

%type argument_expr_list { Vector * }
argument_expr_list(A) ::= assignment_expr(EXPR). {
    A = new_vector();
    vector_append(A, EXPR);
}
argument_expr_list(A) ::= argument_expr_list(EXPR_LIST) COMMA
                          assignment_expr(EXPR). {
    vector_append(EXPR_LIST, EXPR);
    A = EXPR_LIST;
}

/* Postfix expressions */

postfix_expr(A) ::= primary_expr(PRIMARY). { A = PRIMARY; }
postfix_expr ::= postfix_expr LSQUARE expression RSQUARE. // TODO
postfix_expr(A) ::= postfix_expr(POSTFIX) LPAREN argument_expr_list(ARGS)
                    RPAREN. {
    A = malloc_or_die(sizeof(AstNode));
    // TODO: check that the postfix is an ident. Currently if the postfix is
    //       not an ident the program crashes.
    A->node_type = AST_FUNC_CALL;
    A->func_call_ident = strdup(POSTFIX->identifier);
    free_ast(POSTFIX);
    A->func_call_args = ARGS;
}
postfix_expr(A) ::= postfix_expr(POSTFIX) LPAREN RPAREN. {
    A = malloc_or_die(sizeof(AstNode));
    // TODO: check that the postfix is an ident. Currently if the postfix is
    //       not an ident the program crashes.
    A->node_type = AST_FUNC_CALL;
    A->func_call_ident = strdup(POSTFIX->identifier);
    free_ast(POSTFIX);
    A->func_call_args = new_vector();
}

// Structure or union access
postfix_expr(A) ::= postfix_expr(STRUCT) DOT IDENT(IDENT). {
    A = new_ast_struct_member_access(STRUCT, IDENT);
}
postfix_expr(A) ::= postfix_expr(STRUCT) OP_ARROW IDENT(IDENT). {
    A = new_ast_struct_member_access(STRUCT, IDENT);
}

postfix_expr ::= LPAREN type_name RPAREN LBRACE initializer_list RBRACE.
postfix_expr ::= LPAREN type_name RPAREN LBRACE initializer_list COMMA RBRACE.

postfix_expr(A) ::= postfix_expr(EXPR) OP_PLUS_PLUS. {
    A = new_ast_unary_op(UNARY_INC, EXPR);
}
postfix_expr(A) ::= postfix_expr(EXPR) OP_MINUS_MINUS. {
    A = new_ast_unary_op(UNARY_DEC, EXPR);
}

primary_expr(A) ::= IDENT(IDENT). {
    A = new_ast_ident(IDENT);
    free(IDENT);
}
primary_expr(A) ::= constant(CONST). { A = CONST; }
primary_expr(A) ::= STR_LIT(STR).    { A = new_ast_string_lit(STR); }
primary_expr(A) ::= LPAREN expression(EXPR) RPAREN. { A = EXPR; }

// Constants
constant(A) ::= integer_const(CONST).  { A = CONST; }
constant(A) ::= floating_const(CONST). { A = CONST; }
constant(A) ::= CHAR(CHAR). {
    if (strlen(CHAR) > 3)
        warning(cur_filename, cur_line_num,
                "multi-character character constants are not supported.");
    A = new_ast_integer_const(CHAR[1]);
    free(CHAR);
}
constant ::= ENUMERATION_CONSTANT. // TODO

integer_const(A) ::= DECIMAL_CONST(CONST). {
    A = new_ast_integer_const(atoll(CONST));
    free(CONST);
}
integer_const(A) ::= OCTAL_CONST(CONST). {
    A = new_ast_integer_const(strtol(CONST, NULL, 8));
    free(CONST);
}
integer_const(A) ::= HEXADECIMAL_CONST(CONST). {
    A = new_ast_integer_const(strtol(CONST, NULL, 16));
    free(CONST);
}

floating_const(A) ::= DECIMAL_FLOAT(CONST). {
    A = new_ast_float_const(strtold(CONST, NULL));
}
floating_const(A) ::= HEXADECIMAL_FLOAT(CONST). {
    A = new_ast_float_const(strtold(CONST, NULL));
}
