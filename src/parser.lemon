%include {

#include <stdlib.h>
#include <string.h>

#include "ast.h"
#include "error.h"

static char *cur_filename;
static int cur_line_num;
static char *cur_tok_str;

// Root node for the AST
static AstNode *ast_root_node;

}

%syntax_error {
    error(cur_filename, cur_line_num, "unexpected token near \"%s\".",
          cur_tok_str);
}

%parse_accept {
    printf("Parsing done.\n");
}

%parse_failure {
}

%stack_overflow {
    error(cur_filename, cur_line_num, "parser stack overflow.");
}

%code {

extern int yylex();
extern char *yytext;
extern FILE *yyin;
extern int yylineno;

AstNode *parse(char *filename)
{
    cur_filename = filename;
    yyin = fopen(filename, "r");
    void *parser = ParseAlloc(malloc);
    int token_id;

    // Uncomment for debugging
    // ParseTrace(stdout, "Parser: ");

    while ((token_id = yylex())) {
        cur_tok_str = strdup(yytext);
        cur_line_num = yylineno;
        Parse(parser, token_id, strdup(yytext));
    }

    Parse(parser, 0, NULL);
    ParseFree(parser, free);
    fclose(yyin);

    return ast_root_node;
}

}

%token_prefix TOK_
%token_type   { const char * }
%default_type { AstNode * }

%right KWD_IF KWD_ELSE.

program ::= translation_unit(TRANSLATION_UNIT). {
    ast_root_node = TRANSLATION_UNIT;
}

translation_unit(A) ::= external_declaration(EXTERN_DECL). {
    A = malloc(sizeof(AstNode));
    A->node_type = AST_COMPOUND_STMT;
    A->statements = new_vector();
    vector_append(A->statements, EXTERN_DECL);
}
translation_unit(A) ::= translation_unit(TRANSLATION)
                        external_declaration(EXTERN_DECL). {
    vector_append(TRANSLATION->statements, EXTERN_DECL);
    A = TRANSLATION;
}

external_declaration(A) ::= declaration(DECL).             { A = DECL; }
external_declaration(A) ::= function_definition(FUNC_DEF). { A = FUNC_DEF; }

/* Functions */

function_definition(A) ::= declaration_specs(DECL_SPECS)
                           func_declarator(DECLARATOR)
                           compound_statement(BODY). {
    A = DECLARATOR;
    // Check storage-class specifiers
    if (DECL_SPECS->storage_specs &&
        (DECL_SPECS->storage_specs != STORAGE_SPEC_STATIC ||
        DECL_SPECS->storage_specs != STORAGE_SPEC_EXTERN)) {
        error(cur_filename, cur_line_num,
              "invalid storage class specifier for function definition.");
    }
    A->func_params = DECLARATOR->func_params;
    A->func_type = DECL_SPECS;
    A->func_body = BODY;
}
function_definition ::= declaration_specs old_func_declarator declaration_list // TODO
                        compound_statement.

/* Function declarators */

func_declarator(A) ::= func_direct_declarator_head(HEAD)
                       func_direct_declarator_tail(TAIL). {
    A = malloc(sizeof(AstNode));
    A->node_type = AST_FUNCTION_DEF;
    A->func_ident = HEAD->identifier;
    A->func_params = TAIL->func_params;
    free(TAIL);
}
func_declarator ::= pointer func_direct_declarator_head
                    func_direct_declarator_tail. {
    // TODO
}

// Head
func_direct_declarator_head(A) ::= IDENT(IDENT). {
    A = new_ast_ident(IDENT);
}
func_direct_declarator_head(A) ::= LPAREN func_direct_declarator_head(DECL)
                                RPAREN. {
    A = new_ast_ident(DECL->identifier); // FIXME: This might cause problems
}

// Tail
func_direct_declarator_tail(A) ::= LPAREN parameter_type_list(PARAMS) RPAREN. {
    A = malloc(sizeof(AstNode));
    A->node_type = AST_FUNCTION_DEF;
    A->func_params = PARAMS->func_params;
}
func_direct_declarator_tail(A) ::= LPAREN RPAREN. {
    A = malloc(sizeof(AstNode));
    A->node_type = AST_FUNCTION_DEF;
    A->func_params = new_vector();
}

// Old style function declarator
old_func_declarator ::= func_direct_declarator_head // TODO
                        old_func_direct_declarator_tail.
old_func_declarator ::= pointer func_direct_declarator_head
                        old_func_direct_declarator_tail.

// Old style tail
old_func_direct_declarator_tail ::= LPAREN identifier_list RPAREN.
old_func_direct_declarator_tail ::= LPAREN RPAREN.

/* Declarations */

declaration ::= declaration_specs SEMICOLON.
declaration ::= declaration_specs init_declarator_list SEMICOLON.

declaration_list ::= declaration.
declaration_list ::= declaration_list declaration.

// Declaration specifiers
%type declaration_specs { DataType * }
declaration_specs(A) ::= declaration_specs_list(TYPE_LIST). {
    // -1 for unspecified
    int type = -1;
    int is_unsigned = -1;
    int long_cnt = 0;
    int is_short = 0; // 1 if short 0 if not

    int storage_specs = 0;

    // NOTE: This is probably not the best way to do but is was the best I could
    //       think of also this is probably the worst code in the compiler.
    // Parse the list of types.
    for (int i = 0; i < TYPE_LIST->length; i++) {
        switch (*(int *)TYPE_LIST->items[i]) {
        case TYPE_INT:
            if (type > -1)
                error(cur_filename, cur_line_num,
                      "multiple data types in declaration specifiers.");
            else
                type = TYPE_INT;
            break;
        case TYPE_VOID:
            if (type > -1)
                error(cur_filename, cur_line_num,
                      "multiple data types in declaration specifiers.");
            else
                type = TYPE_VOID;
            break;
        case TYPE_CHAR:
            if (type > -1)
                error(cur_filename, cur_line_num,
                      "multiple data types in declaration specifiers.");
            else
                type = TYPE_CHAR;
            break;
        case TYPE_FLOAT:
            if (type > -1)
                error(cur_filename, cur_line_num,
                      "multiple data types in declaration specifiers.");
            else
                type = TYPE_FLOAT;
            break;
        case TYPE_DOUBLE:
            if (type > -1)
                error(cur_filename, cur_line_num,
                      "multiple data types in declaration specifiers.");
            else
                type = TYPE_DOUBLE;
            break;
        case TYPE_BOOL:
            if (type > -1)
                error(cur_filename, cur_line_num,
                      "multiple data types in declaration specifiers.");
            else
                type = TYPE_BOOL;
            break;
        case TYPE_SHORT:
            if (is_short) {
                error(cur_filename, cur_line_num,
                      "\"short\" appears more than once in declaration "
                      "specifiers.");
            } else {
                is_short = 1;
            }
            break;
        case TYPE_LONG: long_cnt++; break;
        case TYPE_SIGNED:
            if (is_unsigned == 1) {
                error(cur_filename, cur_line_num,
                      "\"signed\" and \"unsigned\" in declaration specifiers.");
            } else if (is_unsigned == 0) {
                error(cur_filename, cur_line_num,
                      "more than one \"signed\" in declaration specifiers.");
            } else {
                is_unsigned = 0;
            }
            break;
        case TYPE_UNSIGNED:
            if (is_unsigned == 1) {
                error(cur_filename, cur_line_num,
                      "more than one \"unsigned\" in declaration specifiers.");
            } else if (is_unsigned == 0) {
                error(cur_filename, cur_line_num,
                      "\"signed\" and \"unsigned\" in declaration specifiers.");
            } else {
                is_unsigned = 1;
            }
            break;

        case STORAGE_SPEC_TYPEDEF:
            if (storage_specs) {
                error(cur_filename, cur_line_num,
                      "duplicate \"typedef\" in declaration specifiers.");
            } else {
                storage_specs = STORAGE_SPEC_TYPEDEF;
            }
            break;
        case STORAGE_SPEC_EXTERN:
            if (storage_specs) {
                error(cur_filename, cur_line_num,
                      "duplicate \"extern\" in declaration specifiers.");
            } else {
                storage_specs = STORAGE_SPEC_EXTERN;
            }
            break;
        case STORAGE_SPEC_STATIC:
            if (storage_specs) {
                error(cur_filename, cur_line_num,
                      "duplicate \"static\" in declaration specifiers.");
            } else {
                storage_specs = STORAGE_SPEC_STATIC;
            }
            break;
        case STORAGE_SPEC_AUTO:
            if (storage_specs) {
                error(cur_filename, cur_line_num,
                      "duplicate \"auto\" in declaration specifiers.");
            } else {
                storage_specs = STORAGE_SPEC_AUTO;
            }
            break;
        case STORAGE_SPEC_REGISTER:
            if (storage_specs) {
                error(cur_filename, cur_line_num,
                      "duplicate \"register\" in declaration specifiers.");
            } else {
                storage_specs = STORAGE_SPEC_REGISTER;
            }
            break;
        }
    }

    if (type == -1) {
        if (is_short) {
            type = TYPE_SHORT;
        } else if (long_cnt) {
            type = TYPE_LONG;
        } else if (is_unsigned == 1) {
            type = TYPE_INT;
        } else if (is_unsigned == 0) {
            type = TYPE_INT;
        } else {
            error(cur_filename, cur_line_num,
                  "no type specified in declaration specifiers.");
        }
    }

    if (is_short && type == TYPE_INT) {
        type = TYPE_SHORT;
    }

    if (long_cnt > 2) {
        error(cur_filename, cur_line_num,
              "to many \"long\" types in declaration specifiers.");
    }
    
    if ((long_cnt || is_short) &&
        (type == TYPE_CHAR || type == TYPE_FLOAT || type == TYPE_BOOL)) {
        error(cur_filename, cur_line_num,
              "cannot specify a size for for \"%s\".",
              type_to_string(new_data_type(type, is_unsigned, storage_specs)));
    }

    if (type == TYPE_DOUBLE && is_short) {
        error(cur_filename, cur_line_num,
              "\"double\" and \"short\" in function definition.");
    }

    if (is_unsigned > -1 &&
        (type == TYPE_FLOAT || type == TYPE_DOUBLE || type == TYPE_BOOL)) {
        error(cur_filename, cur_line_num,
              "cannot specify a sign for \"%s\".",
              type_to_string(new_data_type(type, is_unsigned, storage_specs)));
    }

    if (type == TYPE_LONG || type == TYPE_INT) {
        if (long_cnt == 2) {
            type = TYPE_LLONG;
        } else if (long_cnt == 1) {
            type = TYPE_LONG;
        }
    } else if (type == TYPE_DOUBLE) {
        if (long_cnt == 1) {
            type = TYPE_LDOUBLE;
        } else if (long_cnt > 1) {
            error(cur_filename, cur_line_num,
                  "to many \"long\" types for double.");
        }
    }

    // If only sign is specified set type = sign
    A = new_data_type(type, is_unsigned == -1 ? 0 : is_unsigned, storage_specs);
}

%type declaration_specs_list { Vector * }
// Storage class specifiers
declaration_specs_list(A) ::= storage_class_specifier(SPEC). {
    void *new_spec = malloc(sizeof(int));
    *((int*)new_spec) = SPEC;
    A = new_vector();
    vector_append(A, new_spec);
}
declaration_specs_list(A) ::= storage_class_specifier(SPEC)
                              declaration_specs_list(DECL_SPECS). {
    void *new_spec = malloc(sizeof(int));
    *((int*)new_spec) = SPEC;
    vector_append(DECL_SPECS, new_spec);
    A = DECL_SPECS;
}

// Type specifiers
declaration_specs_list(A) ::= type_specifier(TYPE). {
    void *new_type = malloc(sizeof(int));
    *((int*)new_type) = TYPE;
    A = new_vector();
    vector_append(A, new_type);
}
declaration_specs_list(A) ::= type_specifier(NEW_TYPE)
                              declaration_specs_list(DECL_SPECS). {
    void *new_type = malloc(sizeof(int));
    *((int*)new_type) = NEW_TYPE;
    vector_append(DECL_SPECS, new_type);
    A = DECL_SPECS;
}
declaration_specs_list ::= type_qualifier.
declaration_specs_list ::= type_qualifier declaration_specs_list.
declaration_specs_list ::= KWD_INLINE.
declaration_specs_list ::= KWD_INLINE declaration_specs_list.

init_declarator_list ::= init_declarator.
init_declarator_list ::= init_declarator_list COMMA init_declarator.

init_declarator ::= declarator.
init_declarator ::= declarator OP_EQUALS initializer.

%type storage_class_specifier { int }
storage_class_specifier(A) ::= KWD_TYPEDEF. {
    A = STORAGE_SPEC_TYPEDEF;
}
storage_class_specifier(A) ::= KWD_EXTERN. {
    A = STORAGE_SPEC_EXTERN;
}
storage_class_specifier(A) ::= KWD_STATIC. {
    A = STORAGE_SPEC_STATIC;
}
storage_class_specifier(A) ::= KWD_AUTO. {
    A = STORAGE_SPEC_AUTO;
}
storage_class_specifier(A) ::= KWD_REGISTER. {
    A = STORAGE_SPEC_REGISTER;
    // TODO Maybe remove this warning
    warning(cur_filename, cur_line_num, "register keyword is not supported.");
}

specifier_qualifier_list ::= type_specifier.
specifier_qualifier_list ::= type_specifier specifier_qualifier_list.
specifier_qualifier_list ::= type_qualifier.
specifier_qualifier_list ::= type_qualifier specifier_qualifier_list.

// Type specifiers
%type type_specifier { int }
type_specifier(A) ::= KWD_VOID. {
    A = TYPE_VOID;
}
type_specifier(A) ::= KWD_CHAR. {
    A = TYPE_CHAR;
}
type_specifier(A) ::= KWD_SHORT. {
    A = TYPE_SHORT;
}
type_specifier(A) ::= KWD_LONG. {
    A = TYPE_LONG;
}
type_specifier(A) ::= KWD_INT. {
    A = TYPE_INT;
}
type_specifier(A) ::= KWD_FLOAT. {
    A = TYPE_FLOAT;
}
type_specifier(A) ::= KWD_DOUBLE. {
    A = TYPE_DOUBLE;
}
type_specifier(A) ::= KWD_SIGNED. {
    A = TYPE_SIGNED;
}
type_specifier(A) ::= KWD_UNSIGNED. {
    A = TYPE_UNSIGNED;
}
type_specifier(A) ::= KWD_BOOL. {
    A = TYPE_BOOL;
}
type_specifier ::= KWD_IMAGINARY. {
    error(cur_filename, cur_line_num, "complex types not supported.");
}
type_specifier ::= KWD_COMPLEX. {
    error(cur_filename, cur_line_num, "complex types not supported.");
}
type_specifier ::= TYPEDEF_NAME.
type_specifier ::= struct_or_union_specifier.
type_specifier ::= enum_specifier.

// Structs
struct_or_union_specifier ::= struct_or_union IDENT LBRACE
                              struct_declaration_list RBRACE.
struct_or_union_specifier ::= struct_or_union LBRACE struct_declaration_list
                              RBRACE.
struct_or_union_specifier ::= struct_or_union IDENT.

struct_or_union ::= KWD_STRUCT.
struct_or_union ::= KWD_UNION.

struct_declaration_list ::= struct_declaration.
struct_declaration_list ::= struct_declaration_list struct_declaration.

struct_declaration ::= specifier_qualifier_list struct_declarator_list
                       SEMICOLON.

struct_declarator_list ::= struct_declarator.
struct_declarator_list ::= struct_declarator_list COMMA struct_declarator.

struct_declarator ::= declarator.
struct_declarator ::= COLON constant_expr.
struct_declarator ::= declarator COLON constant_expr.

// Enums
enum_specifier ::= KWD_ENUM LBRACE enumerator_list RBRACE.
enum_specifier ::= KWD_ENUM IDENT LBRACE enumerator_list RBRACE.
enum_specifier ::= KWD_ENUM LBRACE enumerator_list COMMA RBRACE.
enum_specifier ::= KWD_ENUM IDENT LBRACE enumerator_list COMMA RBRACE.
enum_specifier ::= KWD_ENUM IDENT.

enumerator_list ::= enumerator.
enumerator_list ::= enumerator_list COMMA enumerator.

enumerator ::= ENUMERATION_CONSTANT.
enumerator ::= ENUMERATION_CONSTANT OP_EQUALS constant_expr.

// Declarator
declarator ::= direct_declarator.
declarator ::= pointer direct_declarator.

// Direct declarator
direct_declarator(A) ::= IDENT(IDENT). {
    A = new_ast_ident(IDENT);
}
direct_declarator ::= LPAREN declarator RPAREN.
direct_declarator ::= direct_declarator LSQUARE RSQUARE.
direct_declarator ::= direct_declarator LSQUARE type_qualifier_list
                      assignment_expr RSQUARE.
direct_declarator ::= direct_declarator LSQUARE assignment_expr RSQUARE.
direct_declarator ::= direct_declarator LSQUARE type_qualifier_list RSQUARE.
direct_declarator ::= direct_declarator LSQUARE KWD_STATIC assignment_expr
                      RSQUARE.
direct_declarator ::= direct_declarator LSQUARE KWD_STATIC type_qualifier_list
                      assignment_expr RSQUARE.
direct_declarator ::= direct_declarator LSQUARE type_qualifier_list KWD_STATIC
                      assignment_expr RSQUARE.
direct_declarator ::= direct_declarator LSQUARE OP_ASTERISK RSQUARE.
direct_declarator ::= direct_declarator LSQUARE type_qualifier_list OP_ASTERISK
                      RSQUARE.
direct_declarator ::= direct_declarator LPAREN parameter_type_list RPAREN.
direct_declarator ::= direct_declarator LPAREN identifier_list RPAREN.
direct_declarator ::= direct_declarator LPAREN RPAREN.

// Pointer
pointer ::= OP_ASTERISK.
pointer ::= OP_ASTERISK type_qualifier_list.
pointer ::= OP_ASTERISK pointer.
pointer ::= OP_ASTERISK type_qualifier_list pointer.

type_qualifier_list ::= type_qualifier.
type_qualifier_list ::= type_qualifier_list type_qualifier.

type_qualifier ::= KWD_CONST.
type_qualifier ::= KWD_RESTRICT.
type_qualifier ::= KWD_VOLATILE.

// Parameters
parameter_type_list(A) ::= parameter_list(PARAMS). { A = PARAMS; }
parameter_type_list ::= parameter_list COMMA ELLIPSIS. // TODO

parameter_list(A) ::= parameter_declaration(PARAM). {
    A = malloc(sizeof(AstNode));
    A->node_type = AST_FUNCTION_DEF;
    A->func_params = new_vector();
    vector_append(A->func_params, PARAM);
}
parameter_list(A) ::= parameter_list(PARAM_LIST) COMMA
                      parameter_declaration(NEW_PARAM). {
    vector_append(PARAM_LIST->func_params, NEW_PARAM);
    A = PARAM_LIST;
}

parameter_declaration(A) ::= declaration_specs(DECL_SPECS). {
    A = new_ast_declaration(DECL_SPECS, NULL);
}
parameter_declaration(A) ::= declaration_specs(DECL_SPECS)
                             declarator(DECLARATOR). {
    A = new_ast_declaration(DECL_SPECS, DECLARATOR);
}

// Type name
type_name ::= specifier_qualifier_list.
type_name ::= specifier_qualifier_list abstract_declarator.

// Direct abstract declarator
direct_abstract_declarator ::= LPAREN abstract_declarator RPAREN.
direct_abstract_declarator ::= LSQUARE RSQUARE.
direct_abstract_declarator ::= LSQUARE assignment_expr RSQUARE.
direct_abstract_declarator ::= direct_abstract_declarator LSQUARE RSQUARE.
direct_abstract_declarator ::= direct_abstract_declarator LSQUARE
                               assignment_expr RSQUARE.
direct_abstract_declarator ::= direct_abstract_declarator LSQUARE OP_ASTERISK
                               RSQUARE.
direct_abstract_declarator ::= LSQUARE OP_ASTERISK RSQUARE.
direct_abstract_declarator ::= LPAREN RPAREN.
direct_abstract_declarator ::= LPAREN parameter_type_list RPAREN.
direct_abstract_declarator ::= direct_abstract_declarator LPAREN RPAREN.
direct_abstract_declarator ::= direct_abstract_declarator LPAREN
                               parameter_type_list RPAREN.

abstract_declarator ::= pointer.
abstract_declarator ::= direct_abstract_declarator.
abstract_declarator ::= pointer direct_abstract_declarator.

// Identifier list
identifier_list ::= IDENT.
identifier_list ::= identifier_list COMMA IDENT.

// Initializer
initializer ::= assignment_expr.
initializer ::= LBRACE initializer_list RBRACE.
initializer ::= LBRACE initializer_list COMMA RBRACE.

initializer_list ::= initializer.
initializer_list ::= designation initializer.
initializer_list ::= initializer_list COMMA initializer.
initializer_list ::= initializer_list COMMA designation initializer.

// Designation
designation ::= designator_list OP_EQUALS.

designator_list ::= designator.
designator_list ::= designator_list designator.

designator ::= LSQUARE constant_expr RSQUARE.
designator ::= DOT IDENT.

/* Statements */

statement(A) ::= labeled_statement(STMT).    { A = STMT; }
statement(A) ::= compound_statement(STMT).   { A = STMT; }
statement(A) ::= expression_statement(STMT). { A = STMT; }
statement(A) ::= selection_statement(STMT).  { A = STMT; }
statement(A) ::= iteration_statement(STMT).  { A = STMT; }
statement(A) ::= jump_statement(STMT).       { A = STMT; }

// Labeled statement
labeled_statement ::= IDENT COLON statement.
labeled_statement ::= KWD_CASE constant_expr COLON statement.
labeled_statement ::= KWD_DEFAULT COLON statement.

// Compound statement
compound_statement(A) ::= LBRACE RBRACE. {
    A = malloc(sizeof(AstNode));
    A->node_type = AST_COMPOUND_STMT;
    A->statements = new_vector();
}
compound_statement(A) ::= LBRACE block_item_list(BLOCK_ITEM_LIST) RBRACE. {
    A = BLOCK_ITEM_LIST;
}

block_item_list(A) ::= block_item(ITEM). {
    A = malloc(sizeof(AstNode));
    A->node_type = AST_COMPOUND_STMT;
    A->statements = new_vector();
    vector_append(A->statements, ITEM);
}
block_item_list(A) ::= block_item_list(ITEM_LIST) block_item(NEW_ITEM). {
    vector_append(ITEM_LIST->statements, NEW_ITEM);
    A = ITEM_LIST;
}

block_item ::= declaration.
block_item ::= statement.

// Expr statement
expression_statement(A) ::= expression(EXPR) SEMICOLON. {
    A = malloc(sizeof(AstNode));
    A->node_type = AST_EXPR_STMT;
    A->expression = EXPR;
}

// If else
selection_statement ::= KWD_IF LPAREN expression RPAREN statement. [KWD_ELSE]
selection_statement ::= KWD_IF LPAREN expression RPAREN statement KWD_ELSE
                        statement.

// Switch statement
selection_statement ::= KWD_SWITCH LPAREN expression RPAREN statement.

// While and do while
iteration_statement ::= KWD_WHILE LPAREN expression RPAREN statement.
iteration_statement ::= KWD_DO statement KWD_WHILE LPAREN expression RPAREN
                        SEMICOLON.
// For loop
iteration_statement ::= KWD_FOR LPAREN expression_statement expression_statement
                        expression RPAREN statement.
iteration_statement ::= KWD_FOR LPAREN expression_statement expression_statement
                        RPAREN statement.
iteration_statement ::= KWD_FOR LPAREN declaration expression_statement
                        expression RPAREN statement.
iteration_statement ::= KWD_FOR LPAREN declaration expression_statement
                        RPAREN statement.

// Jump statements
jump_statement ::= KWD_GOTO IDENT SEMICOLON.
jump_statement ::= KWD_CONTINUE SEMICOLON.
jump_statement ::= KWD_BREAK SEMICOLON.
jump_statement(A) ::= KWD_RETURN SEMICOLON. {
    A = malloc(sizeof(AstNode));
    A->node_type = AST_RETURN_STMT;
    A->return_expr = NULL;
}
jump_statement(A) ::= KWD_RETURN expression(EXPR) SEMICOLON. {
    A = malloc(sizeof(AstNode));
    A->node_type = AST_RETURN_STMT;
    A->return_expr = EXPR;
}

/* Expressions */

constant_expr(A) ::= conditional_expr(COND). { A = COND; }

expression(A) ::= assignment_expr(ASSIGNMENT). { A = ASSIGNMENT; }
expression ::= expression COMMA assignment_expr. // TODO

// Assignment operators
assignment_op ::= OP_EQUALS.
assignment_op ::= OP_TIMES_EQUALS.
assignment_op ::= OP_DIVIDE_EQUALS.
assignment_op ::= OP_MODULO_EQUALS.
assignment_op ::= OP_PLUS_EQUALS.
assignment_op ::= OP_MINUS_EQUALS.
assignment_op ::= OP_SHIFT_LEFT_EQUALS.
assignment_op ::= OP_SHIFT_RIGHT_EQUALS.
assignment_op ::= OP_AND_EQUALS.
assignment_op ::= OP_XOR_EQUALS.
assignment_op ::= OP_OR_EQUALS.

// Assignment expression
assignment_expr(A) ::= conditional_expr(COND). { A = COND; }
assignment_expr ::= unary_expr assignment_op assignment_expr.

conditional_expr(A) ::= logical_or_expr(LOGICAL_OR). { A = LOGICAL_OR; }
conditional_expr ::= logical_or_expr QUESTION_MARK expression COLON
                     conditional_expr.

logical_or_expr(A) ::= logical_and_expr(LOGICAL_AND). { A = LOGICAL_AND; }
logical_or_expr(A) ::= logical_or_expr(LHS) OP_LOGICAL_OR
                       logical_and_expr(RHS). {
    A = new_ast_binary_op(OP_LOGICAL_OR, LHS, RHS);
}

logical_and_expr(A) ::= inclusive_or_expr(INCLUSIVE). { A = INCLUSIVE; }
logical_and_expr(A) ::= logical_and_expr(LHS) OP_LOGICAL_AND
                        inclusive_or_expr(RHS). {
    A = new_ast_binary_op(OP_LOGICAL_AND, LHS, RHS);
}

inclusive_or_expr(A) ::= exclusive_or_expr(EXCLUSIVE). { A = EXCLUSIVE; }
inclusive_or_expr(A) ::= inclusive_or_expr(LHS) OP_OR exclusive_or_expr(RHS). {
    A = new_ast_binary_op(OP_BITWISE_OR, LHS, RHS);
}

exclusive_or_expr(A) ::= and_expr(AND). { A = AND; }
exclusive_or_expr(A) ::= exclusive_or_expr(LHS) OP_CARET and_expr(RHS). {
    A = new_ast_binary_op(OP_BITWISE_XOR, LHS, RHS);
}

and_expr(A) ::= equality_expr(EQUALITY). { A = EQUALITY; }
and_expr(A) ::= and_expr(LHS) OP_AND equality_expr(RHS). {
    A = new_ast_binary_op(OP_BITWISE_AND, LHS, RHS);
}

// Equality check
equality_expr(A) ::= relational_expr(RELATIONAL). { A = RELATIONAL; }
equality_expr(A) ::= equality_expr(LHS) OP_EQUALITY relational_expr(RHS). {
    A = new_ast_binary_op(OP_EQUALITY, LHS, RHS);
}
equality_expr(A) ::= equality_expr(LHS) OP_NOT_EQUAL relational_expr(RHS). {
    A = new_ast_binary_op(OP_NOT_EQUAL, LHS, RHS);
}

// Realational expressions
relational_expr(A) ::= shift_expr(SHIFT). { A = SHIFT; }
relational_expr(A) ::= relational_expr(LHS) OP_LESS_THAN shift_expr(RHS). {
    A = new_ast_binary_op(OP_LESS_THAN, LHS, RHS);
}
relational_expr(A) ::= relational_expr(LHS) OP_GREATER_THAN shift_expr(RHS). {
    A = new_ast_binary_op(OP_GREATER_THAN, LHS, RHS);
}
relational_expr(A) ::= relational_expr(LHS) OP_LESS_THAN_OR_EQUAL
                       shift_expr(RHS). {
    A = new_ast_binary_op(OP_LESS_THAN_EQUAL, LHS, RHS);
}
relational_expr(A) ::= relational_expr(LHS) OP_GREATER_THAN_OR_EQUAL
                       shift_expr(RHS). {
    A = new_ast_binary_op(OP_GREATER_THAN_EQUAL, LHS, RHS);
}

// Shift expression TODO
shift_expr(A) ::= additive_expr(ADD).  { A = ADD; }
shift_expr ::= shift_expr OP_SHIFT_LEFT additive_expr.
shift_expr ::= shift_expr OP_SHIFT_RIGHT additive_expr.

// Addition
additive_expr(A) ::= multiplicative_expr(MULT_EXPR). { A = MULT_EXPR; }
additive_expr(A) ::= additive_expr(LHS) OP_PLUS multiplicative_expr(RHS). {
    A = new_ast_binary_op(OP_PLUS, LHS, RHS);
}
additive_expr(A) ::= additive_expr(LHS) OP_MINUS multiplicative_expr(RHS). {
    A = new_ast_binary_op(OP_MINUS, LHS, RHS);
}

// Multiplication
multiplicative_expr(A) ::= cast_expr(CAST). { A = CAST; }
multiplicative_expr(A) ::= multiplicative_expr(LHS) OP_ASTERISK
                           cast_expr(RHS). {
    A = new_ast_binary_op(OP_MULT, LHS, RHS);
}
multiplicative_expr(A) ::= multiplicative_expr(LHS) OP_DIVIDE cast_expr(RHS). {
    A = new_ast_binary_op(OP_DIV, LHS, RHS);
}
multiplicative_expr(A) ::= multiplicative_expr(LHS) OP_MODULO cast_expr(RHS). {
    A = new_ast_binary_op(OP_MODULO, LHS, RHS);
}

// TODO finish expression parsing
cast_expr(A) ::= unary_expr(UNARY). { A = UNARY; }
cast_expr ::= LPAREN type_name RPAREN cast_expr.

unary_op ::= OP_AND.
unary_op ::= OP_ASTERISK.
unary_op ::= OP_PLUS.
unary_op ::= OP_MINUS.
unary_op ::= OP_TILDE.
unary_op ::= OP_NOT.

unary_expr(A) ::= postfix_expr(POSTFIX). { A = POSTFIX; }
unary_expr ::= OP_PLUS_PLUS unary_expr.
unary_expr ::= OP_MINUS_MINUS unary_expr.
unary_expr ::= unary_op cast_expr.
unary_expr ::= OP_SIZEOF unary_expr.
unary_expr ::= OP_SIZEOF LPAREN type_name RPAREN.

argument_expr_list ::= assignment_expr.
argument_expr_list ::= argument_expr_list COMMA assignment_expr.

postfix_expr(A) ::= primary_expr(PRIMARY). { A = PRIMARY; }
postfix_expr ::= postfix_expr LSQUARE expression RSQUARE.
postfix_expr ::= postfix_expr LPAREN argument_expr_list RPAREN.
postfix_expr ::= postfix_expr DOT IDENT.
postfix_expr ::= postfix_expr OP_ARROW IDENT.
postfix_expr ::= postfix_expr OP_PLUS_PLUS.
postfix_expr ::= postfix_expr OP_MINUS_MINUS.
postfix_expr ::= LPAREN type_name RPAREN LBRACE initializer_list RBRACE.
postfix_expr ::= LPAREN type_name RPAREN LBRACE initializer_list COMMA RBRACE.

primary_expr ::= IDENT.
primary_expr(A) ::= constant(CONST). { A = CONST; }
primary_expr ::= STR_LIT.
primary_expr ::= LPAREN expression RPAREN.

// Constants
constant(A) ::= integer_const(CONST). { A = CONST; }
constant ::= floating_const.
constant ::= CHAR.
constant ::= ENUMERATION_CONSTANT.

integer_const(A) ::= DECIMAL_CONST(CONST). {
    A = new_ast_integer_const(atoi(CONST));
}
integer_const ::= OCTAL_CONST.
integer_const ::= HEXADECIMAL_CONST.
// TODO: check integer constants

floating_const ::= DECIMAL_FLOAT.
floating_const ::= HEXADECIMAL_FLOAT.
